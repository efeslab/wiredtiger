/*! @arch_page arch-concurrency WiredTiger concurrency management

WiredTiger is a multi-threaded application and needs to manage concurrent access to shared memory
locations. Many mechanisms are defined in WiredTiger to safely access shared memory locations. This
page describes what those mechanisms are and the intended usage of them in the code base.

@section volatile Volatile

A controversial tool in the C toolkit. WiredTiger utilizes volatile for one reason, managing
compiler optimization. Leveraging the definitions from "Is Parallel Programming Hard, And, If So,
What Can You Do About It?", Paul E. McKenney, WiredTiger utilizes volatile to prevent the
following type of compiler optimizations: Load fusing, store fusing, invented loads, invented
stores and code reordering. WiredTiger defines the following macros WT_READ_ONCE and
WT_WRITE_ONCE, these macros, if used correctly, prevent the described forms of compiler
optimization. Additionally some variables in WiredTiger are defined with the volatile keyword if
it is known that they will be frequently accessed in a concurrent context.

@section locking Locking

There are three types of locks in WiredTiger:
 - Condition Variables
 - Spin Locks
 - Read Write Locks
Each mechanism guarantees that once a thread relinquishes its lock and another thread obtains the
same lock, all modifications made by the first thread will be visible to the thread now holding
the lock.

@subsection condition-vars Condition Variables

Condition variables are used to force a thread to wait until a certain condition is fulfilled. A
common usage pattern is as follows: a thread is waiting for a signal to wake up, and once the
required condition is met, another thread will then send the signal to one of the waiting
threads. There are two implementations of condition variables in WiredTiger respectively for
POSIX and MSVC under the same interface. The specific implementation is determined at compile
time based on the platform.

@subsection spin-locks Spin Locks

A spin lock forces any thread trying to obtain it to wait in a loop while repeatedly checking
whether the lock is available. Only one thread is able to have the lock at any given time,
effectively serializing the execution of the critical sections. There are three different
implementations for spin locks in WiredTiger under the same interface:
 - An implementation using GCC's builtin atomic operations.
 - An implementation using a POSIX based mutex.
 - An implementation for MSVC.
The specific implementation is determined at compile time based on the platform and compile-time
configurations.
A spin lock is an exclusive lock that generally expects all reads and writes on shared memory
locations under its protection to be performed under the lock. In WiredTiger this pattern
occasionally is not upheld and we read variables written to within the lock without locking. Such
instances are only permitted if reading inconsistent data is sufficient for the use case.

@subsection rw-locks Read Write locks
A read-write lock allows concurrent shared access for read-only operations, whereas write
operations require exclusive access. This means that multiple threads can read the data in
parallel but an exclusive lock is needed for writing or modifying data. When a writer is writing
data, all other writers and readers will be blocked until the writer is finished writing.
WiredTiger has its own read-write lock implementation. It is based on atomic operations and
condition variables.
It is expected that all the reads and writes of a shared variable protected by a read-write lock
will be performed under the lock. For the same reason as spinlocks, WiredTiger may allow usages
that read the shared variables without taking the lock. Such instances are only permitted if
reading inconsistent data is sufficient for the use case.

@section atomics Atomics

As previously mentioned WiredTiger already expects loads and stores to specific sizes of points
to be atomic and prevent tearing. WiredTiger also relies on atomic RMW operations, these include:
- Compare and Swap
- Fetch add / sub
- Add / sub fetch
Currently WiredTiger is undergoing a transition where all shared memory variable access will be
wrapped by an atomic function, this will enable TSan to run on the code base.

@section memory-barriers Memory Barriers

WiredTiger utilizes memory barriers in a number of places to ensure that CPU instruction
reordering doesn't result in a concurrency bug. Specifically CPUs are allowed to reorder load and
store instructions. If this occurs when two threads are reading or writing to the same shared
memory locations it can result in those threads seeing what would otherwise be impossible values.

WiredTiger defines barriers by describing which kind of reordering they prevent, for example a
LoadLoad barrier prevents load instructions before the barrier from being reordered with load
instructions after the barrier. Using this definition we can define 4 types of reorderings,
LoadLoad, StoreStore, LoadStore and StoreLoad. To simplify the barrier semantics further
WiredTiger defines acquire and release barriers, firstly we have the WT_ACQUIRE_READ_WITH_BARRIER
macro which prevents LoadLoad and LoadStore reorderings. Next we have the
WT_RELEASE_WRITE_WITH_BARRIER macro which prevents StoreStore and LoadStore reorderings, these
barriers should be used as pairs. If one location requires an acquire barrier then there must be
another location that requires a release barrier. Two more barrier constructs are defined in
WiredTiger. WT_FULL_BARRIER which prevents all 4 kinds of described reorderings and
WT_COMPILER_BARRIER which is a basic compiler barrier preventing compiler optimization from
occurring across it, the compiler barrier does not impact CPU reordering.

Previously WiredTiger defined a WT_PUBLISH macro which prevented StoreStore reordering, this
macro has since been removed however the term publish still exists in the code base. This is
used to refer to writing a value to a shared memory location. It doesn't define any memory
ordering semantics.

@section marked-access Marked Access
Barriers are a heavy hammer for situations that only need to prevent reordering of instructions
on one side of a load or store. To reduce the amount of reorderings prevented, and to access an
ARM specific optimization WiredTiger defines two marked access macros. These are loads and stores
that prevent reordering from one direction across that load or store. Firstly there is the
WT_ACQUIRE_READ, this prevents loads and stores following the load from being reordered across
it. Then we have the WT_RELEASE_WRITE macro which prevents loads and stores prior to the store
from being reordered across it. As with the acquire and release barriers these marked access
macros should be paired together to function correctly.

*/
